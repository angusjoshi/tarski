\chapter{Testing the Algorithms}
\newcommand{\code}[1]{\lstinline|#1|}
\section{Overview}
While the algorithms of previous sections are of great theoretical interest,
questions remain on their practicality. To address this,
I have implemented the algorithms and tested their performance on
randomly generated instances of $\arr$, simple stochastic games, and
shapley's stochastic games. The notable conclusions are roughly speaking as follows,
\begin{itemize}
  \item the most basic \cref{kleeneTarski} outperforms all of the
more complex algorithms in all cases in terms of query count and time,
\item the least performant algorithm in all cases is found to be \cref{dQiYiAlg} in both
  query count and time,
  \item the fixpoint decomposition method described in \cref{fixDecompChapter} performs better than the asymptotically superior
monotone decomposition method described in \cref{monotoneDecompChap}.
\end{itemize}
\input{chapters/testing-the-algorithms/method.tex}
\subsection{Algorithm Implementation Detail}
\subsubsection{Detail}
I implemented these algorithms in the progamming language C++. 
Complete source code can be found \href{https://github.com/angusjoshi/tarski}{here}.
Implementation follows the description of the algorithms from previous chapters closely,
and I will not share too much detail on my code for fear of it not being helpful. The interested
reader is instead urged to read the code linked above. Compilation and linking was done with
clang version 14.0.3 with the C++20 standard and \lstinline{-03} optimization settings.
Soplex\citep{soplex} was used as a dependency to solve linear programs
as part of the shapley's stochastic games solver, and GMP\citep{gmp} was used for multiprecision types. \\
\subsubsection{Performance Improvements}
There are certainly performance optimizations that could be made. For simplicity of implementation\footnote{particularly
in implementing slices of functions as described in \cref{sliceDef}},
elements of array-backed \lstinline{std::vector}s are shuffled around when not necessary, and I believe
performance could be gained by changing this. \lstinline{std::function} is the main abstraction for passing
the monotone functions around the system and are shown to be particularly innefficient in \citep{stdFunctionBad},
so I believe performance can be gained by changing this to something like the \lstinline{function_view} described in \citep{stdFunctionBad}.
I seem to achieve particularly poor performance with the \lstinline{soplex} LP solver used while solving shapley's stochastic games.
I believe this is because \lstinline{soplex} is not optimized for solving a large number of very small LPs,
so perhaps there is a better alternative for this application. There is also perhaps scope for using sensitivity
analysis as described in \citep{sensAnalysis} to reuse values from previous function queries to improve
solver performance; although this could be incredibly complex and not worth the effort.

\subsection{Random Problem Generation}
Instances of all three problems were generated randomly to facilitate testing. The method of randomization used
for each instance is detailed in this subsection. Throughout random numbers were generated using tools
from the \lstinline{<random>} header in the C++ standard library.

\subsubsection{\arr}
Recall from \cref{arr} that an instance of the arrival problem consists of a directed graph with
a designated target vertex such that every vertex as exactly two labelled outgoing edges.
This leads to a natural notion of a random arrival instance on $n$ vertices $v_1, ..., v_n$.
Simply choose for each vertex $v_i$ the successors $s_0(v_i)$ and $s_1(v_i)$ uniformly at random
from the set of vertices, and note that it is without loss of generality to fix the target to be $v_n$.
Random instances for various fixed sizes of the $\arr$ problem were generated thusly for testing.

\subsubsection{Simple Stochastic Games}
Simple stochastic games do not have as natural a notion of random problem instances as $\arr$ for the following reasons,
\begin{itemize}
  \item vertices can be one of three types, 
  \item vertices can have different numbers of successors,
  \item chance vertices can have arbitrary probability distributions on their successors.
\end{itemize}
For simplicity, I generate a random simple stochastic game on $n$ vertices $v_1, ..., v_n$ as follows,
\begin{itemize}
  \item the type of each vertex is chosen uniformly at random from the three possibilities,
  \item all vertices have exactly two successors,
  \item the probability distribution on the two successors of a chance node is chosen by
    partitioning the interval $[0, 1]$ with a number chosen uniformly at random from the range $[0, 1]$.
  \item $v_n$ is fixed to be the target for the maximizer.
\end{itemize}

\subsubsection{Shapley's Stochastic Games}
The degrees of freedom for defining an instance of shapley's stochastic games are as follows,
\begin{itemize}
  \item action sets can have arbitrary size at each state,
  \item for each joint action at each state, an arbitrary probability distribution on the all
    the states in the game can be chosen,
  \item payoffs for each joint action for each state can be chosen arbitrarily.
\end{itemize}
In order, these are addressed as follows,
\begin{itemize}
  \item both players have three actions at every state,
  \item payoff and successor matrices are all $3 \times 3$ (which follows from the above item),
  \item every entry in every successor matrix is a probability distribution on exactly two vertices.
    That is to say that at every state when a joint action is chosen the transition is chosen
    to be one of two states,
  \item every probability distribution in the successor matrix is chosen as a u.a.r. partition of $[0, 1]$
    as in the simple stochastic game case,
  \item all entries of the payoff matrices are chosen to be u.a.r. integers in the range $[-M, M]$ for some
    fixed $M \in \zpos$.
\end{itemize}
\subsubsection{Limitations}
I acknowledge that testing with random instances in this fashion is necessarily limited; the results
shown later give evidence that random generation in this fashion does not tend to generate 'hard' instances.
For example, as will be shown[maybe add label to section], the length of the walk in a random instance
of the $\arr$ problem as described above seems to scale linearly with the size of the problem despite
the fact that in the worst case the walk can have an exponential length.

\subsection{Testing Protocol}
asdf
